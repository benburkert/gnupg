package gnupg

import (
	"bytes"
	"encoding/hex"
	"io"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/benburkert/gnupg/internal/gpgtest"
	"github.com/benburkert/openpgp/algorithm"
	"github.com/benburkert/openpgp/packet"
)

const (
	// privKeyEdDSAHex contains an EdDSA private key generated with GnuPG 2.1.
	privKeyEdDSAHex = "94860456e2132b16092b06010401da470f01010740bbda39266affa511a8c2d02edf690fb784b0499c4406185811a163539ef11dc1fe07030228e2c8ebd6e3e0a6e4d9f0324b4594c171f1f5e2fb0d9fa310c2690ab6637a3b3577620fa783a628231b4c6f2607f30b5a01bdedbd66a5f8c62dcd8f1e604d1c51eb906343442606f8cc6d8d208fd1b41d74657374696e67203c74657374696e674074657374696e672e636f6d3e8879041316080021050256e2132b021b03050b09080702061508090a0b020416020301021e01021780000a09100907e75e1dd99ad86d0c00fe39d2008359352782bc9b61ac382584cd8eff3f57a18c2287e3afeeb05d1f04ba00fe2d0bc1ddf3ff8adb9afa3e7d9287244b4ec567f3db4d60b74a9b5465ed528203"

	// pubKeyEdDSAHex contains the EdDSA public key for the above private key.
	pubKeyEdDSAHex = "98330456e2132b16092b06010401da470f01010740bbda39266affa511a8c2d02edf690fb784b0499c4406185811a163539ef11dc1b41d74657374696e67203c74657374696e674074657374696e672e636f6d3e8879041316080021050256e2132b021b03050b09080702061508090a0b020416020301021e01021780000a09100907e75e1dd99ad86d0c00fe39d2008359352782bc9b61ac382584cd8eff3f57a18c2287e3afeeb05d1f04ba00fe2d0bc1ddf3ff8adb9afa3e7d9287244b4ec567f3db4d60b74a9b5465ed528203"

	// sigDataEdDSAHex contains a signature over the data "testing" using the
	// above private key.
	sigDataEdDSAHex = "885e040016080006050256e21408000a09100907e75e1dd99ad837c30100c3e7149546f2113bfffaa72f680ce9b9d30c176b51e9f3908b968d6a46b3fbc10100e642c7db3fb461ac440f1ccb66b8fceb6e452ae1a350ffb671d3e9005a6fcb08"
)

// TestSignature performs sanity checks on signatures generated by
// this package.
func TestSignature(t *testing.T) {
	privKey := testKey(t)

	p, err := packet.Read(readerFromHex(sigDataEdDSAHex))
	if err != nil {
		t.Fatalf("didn't parse a Signature: %s", err)
	}

	goodSig, ok := p.(*packet.Signature)
	if !ok {
		t.Fatal("failed to parse Signature: %#v", p)
	}

	h := goodSig.Hash.New()
	h.Reset()
	io.Copy(h, bytes.NewBufferString("testing"))
	if err := privKey.PublicKey.VerifySignature(h, goodSig); err != nil {
		t.Fatalf("failed to verify signature: %s", err)
	}

	sig := new(packet.Signature)
	sig.SigType = packet.SigTypeBinary
	sig.PubKeyAlgo = privKey.PubKeyAlgo
	sig.Hash = algorithm.SHA256
	sig.CreationTime = time.Unix(1457656619, 0)
	sig.IssuerKeyId = &privKey.KeyId

	h = sig.Hash.New()
	io.Copy(h, bytes.NewBufferString("testing"))
	if err = sig.Sign(h, privKey, nil); err != nil {
		t.Fatalf("failed to sign: %s", err)
	}

	out := new(bytes.Buffer)
	if err = sig.Serialize(out); err != nil {
		t.Errorf("failed to serialize: %s", err)
	}

	if p, err = packet.Read(out); err != nil {
		t.Fatalf("didn't reparse a Signature: %s", err)
	}

	sig, ok = p.(*packet.Signature)
	if !ok {
		t.Fatal("failed to reparse Signature: %#v", p)
	}

	h.Reset()
	io.Copy(h, bytes.NewBufferString("testing"))
	if err := privKey.PublicKey.VerifySignature(h, sig); err != nil {
		t.Errorf("failed to reverify signature: %s", err)
	}
}

// TestSignature uses gpg2 to check a signature generated by this package.
func TestGPG2Interop(t *testing.T) {
	gpg2, err := gpgtest.NewGPG2()
	if err != nil {
		t.Skipf("skipping GnuPG interop test: %s", err)
	}
	defer gpg2.Close()

	// TODO: perform key generation. For now, use the
	// pre-generated key.
	keyFile, err := os.Create(filepath.Join(gpg2.HomeDir, "test.key"))
	if err != nil {
		t.Fatal(err)
	}
	if _, err := io.Copy(keyFile, readerFromHex(pubKeyEdDSAHex)); err != nil {
		t.Fatal(err)
	}
	if stdout, stderr, err := gpg2.Run("--import", keyFile.Name()); err != nil {
		t.Logf("stdout: %q", string(stdout.Bytes()))
		t.Logf("stderr: %q", string(stderr.Bytes()))
		t.Fatal(err)
	}
	keyFile.Close()

	msg := bytes.NewBufferString("testing")
	msgFile, err := os.Create(filepath.Join(gpg2.HomeDir, "test"))
	if err != nil {
		t.Fatal(err)
	}
	if _, err := io.Copy(msgFile, bytes.NewBuffer(msg.Bytes())); err != nil {
		t.Fatal(err)
	}
	msgFile.Close()

	privKey := testKey(t)

	sig := new(packet.Signature)
	sig.SigType = packet.SigTypeBinary
	sig.PubKeyAlgo = privKey.PubKeyAlgo
	sig.Hash = algorithm.SHA512
	sig.CreationTime = time.Now()
	sig.IssuerKeyId = &privKey.KeyId

	h := sig.Hash.New()
	if _, err := io.Copy(h, msg); err != nil {
		t.Fatal(err)
	}
	if err := sig.Sign(h, privKey, nil); err != nil {
		t.Fatalf("failed to sign: %s", err)
	}

	sigFile, err := os.Create(filepath.Join(gpg2.HomeDir, "test.sig"))
	if err != nil {
		t.Fatal(err)
	}
	if err = sig.Serialize(sigFile); err != nil {
		t.Errorf("failed to serialize: %s", err)
	}
	sigFile.Close()

	stdout, stderr, err := gpg2.Run("--verify", sigFile.Name(), msgFile.Name())
	if err != nil {
		t.Logf("stdout: %q", string(stdout.Bytes()))
		t.Logf("stderr: %q", string(stderr.Bytes()))
		t.Errorf("gpg2 --verify failed: %s", err)
	}

	if err := privKey.Serialize(&bytes.Buffer{}); err != nil {
		t.Fatal(err)
	}
}

// readerFromHex takes a hex-encoded string and returns an io.Reader
// with the decoded data.
func readerFromHex(s string) io.Reader {
	data, err := hex.DecodeString(s)
	if err != nil {
		panic("readerFromHex: bad input")
	}
	return bytes.NewBuffer(data)
}

// privKeyPassphrase is the passphrase that was set on the key.
var privKeyPassphrase = "testing"

func testKey(t *testing.T) *packet.PrivateKey {
	p, err := packet.Read(readerFromHex(privKeyEdDSAHex))
	if err != nil {
		t.Fatalf("didn't parse a PrivateKey: %s", err)
	}

	privKey, ok := p.(*packet.PrivateKey)
	if !ok {
		t.Fatal("failed to parse PrivateKey: %#v", p)
	}
	if err := privKey.Decrypt([]byte(privKeyPassphrase)); err != nil {
		t.Fatal("failed to decrypt: %s", err)
	}
	return privKey

}
